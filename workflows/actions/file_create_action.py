"""
File creation action for workflows.

This module implements a file creation action for the workflow engine,
allowing workflows to output data from previous actions to files in various formats.
"""

import logging
import json
import time
import os
import csv
import traceback
from typing import Dict, Any, Optional, Tuple, List
from datetime import datetime

from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from django.conf import settings

from workflows.models import Action, ActionExecution, WorkflowExecution, WorkflowAction

logger = logging.getLogger(__name__)

class FileCreateAction:
    """
    Implementation of file creation action for workflows.
    
    This action creates files from data generated by previous actions in the workflow.
    It supports various output formats and configuration options.
    """
    
    def __init__(self, action: Action):
        """
        Initialize the file creation action.
        
        Args:
            action: Action model instance
        """
        self.action = action
        self.parameters = action.parameters or {}
    
    def run(
        self, 
        action_execution: ActionExecution, 
        execution_params: Dict[str, Any]
    ) -> Tuple[bool, Dict[str, Any]]:
        """
        Execute the file creation action.
        
        Args:
            action_execution: ActionExecution model instance
            execution_params: Parameters for this execution
            
        Returns:
            Tuple of (success, result_data)
        """
        start_time = time.time()
        
        try:
            # Update execution status
            action_execution.start()
            
            # Merge default parameters with execution parameters
            params = {**self.parameters, **execution_params}
            
            # Extract required parameters
            file_format = params.get('file_format', 'csv')
            filename = params.get('filename', f'output_{datetime.now().strftime("%Y%m%d_%H%M%S")}.{file_format}')
            data_source = params.get('data_source', 'previous_action')  # previous_action, custom_data, etc.
            previous_action_id = params.get('previous_action_id')
            previous_action_seq = params.get('previous_action_sequence')
            include_headers = params.get('include_headers', True)
            header_fields = params.get('header_fields', [])  # List of field names for headers
            selected_fields = params.get('selected_fields', [])  # List of fields to include
            
            # Get the data to write to the file
            data = self._get_data(
                action_execution.workflow_execution,
                data_source,
                previous_action_id,
                previous_action_seq,
                params
            )
            
            if not data:
                error = "No data available to write to file"
                action_execution.complete('warning', error_message=error)
                return False, {"error": error}
            
            # Create the output directory if it doesn't exist
            output_dir = params.get('output_directory', os.path.join(settings.MEDIA_ROOT, 'workflow_files'))
            os.makedirs(output_dir, exist_ok=True)
            
            # Create the full path to the output file
            file_path = os.path.join(output_dir, filename)
            
            # Write the file based on the selected format
            success, error = self._write_file(
                data, 
                file_path, 
                file_format, 
                include_headers,
                header_fields,
                selected_fields,
                params
            )
            
            if not success:
                action_execution.complete('error', error_message=error)
                return False, {"error": error}
            
            # Calculate execution time
            execution_time = time.time() - start_time
            
            # Prepare result data
            result_data = {
                "success": True,
                "execution_time": f"{execution_time:.2f}s",
                "file_path": file_path,
                "file_format": file_format,
                "record_count": len(data) if isinstance(data, list) else 1,
            }
            
            # Complete the execution
            action_execution.complete('success', output_data=result_data)
            
            return True, result_data
            
        except Exception as e:
            execution_time = time.time() - start_time
            error_message = f"Error creating file: {str(e)}\n{traceback.format_exc()}"
            logger.error(error_message)
            
            # Complete the execution with error
            action_execution.complete('error', error_message=str(e))
            
            return False, {
                "success": False,
                "execution_time": f"{execution_time:.2f}s",
                "error": str(e)
            }
    
    def _get_data(
        self,
        workflow_execution: WorkflowExecution,
        data_source: str,
        previous_action_id: Optional[int] = None,
        previous_action_seq: Optional[int] = None,
        params: Optional[Dict[str, Any]] = None
    ) -> Any:
        """
        Get data from the specified source.
        
        Args:
            workflow_execution: Current workflow execution
            data_source: Source of the data (previous_action, custom_data, etc.)
            previous_action_id: ID of the previous action to get data from
            previous_action_seq: Sequence number of the previous action
            params: Additional parameters
            
        Returns:
            Data to write to the file
        """
        if data_source == 'previous_action':
            # Get data from a previous action in the workflow
            if previous_action_id:
                # Get execution by action ID
                previous_execution = workflow_execution.action_executions.filter(
                    workflow_action__action_id=previous_action_id,
                    status='success'
                ).order_by('-end_time').first()
            elif previous_action_seq:
                # Get execution by sequence number
                previous_execution = workflow_execution.action_executions.filter(
                    workflow_action__sequence=previous_action_seq,
                    status='success'
                ).first()
            else:
                # Default to getting the execution immediately before this one
                current_sequence = ActionExecution.objects.get(pk=workflow_execution.pk).workflow_action.sequence
                previous_execution = workflow_execution.action_executions.filter(
                    workflow_action__sequence__lt=current_sequence,
                    status='success'
                ).order_by('-workflow_action__sequence').first()
                
            if not previous_execution:
                logger.error("No previous successful action execution found")
                return None
                
            # Extract result data from the previous execution
            output_data = previous_execution.output_data or {}
            
            # Look for data in standard locations depending on action type
            if 'result' in output_data:
                return output_data['result']
            elif 'data' in output_data:
                return output_data['data']
            else:
                # Just return the whole output data
                return output_data
                
        elif data_source == 'custom_data':
            # Use data directly provided in parameters
            return params.get('custom_data')
            
        elif data_source == 'workflow_context':
            # Get data from the workflow execution context
            return workflow_execution.parameters.get('data')
        
        # Default
        return None
    
    def _write_file(
        self,
        data: Any,
        file_path: str,
        file_format: str,
        include_headers: bool,
        header_fields: List[str],
        selected_fields: List[str],
        params: Dict[str, Any]
    ) -> Tuple[bool, str]:
        """
        Write data to a file in the specified format.
        
        Args:
            data: Data to write
            file_path: Path to the output file
            file_format: Format of the output file (csv, json, etc.)
            include_headers: Whether to include headers in the file
            header_fields: Custom header field names
            selected_fields: Fields to include in the output
            params: Additional parameters
            
        Returns:
            Tuple of (success, error_message)
        """
        try:
            # Standardize data format for processing
            records = self._standardize_data(data)
            
            if not records:
                return False, "No valid data to write"
            
            # Apply field selection if specified
            if selected_fields:
                filtered_records = []
                for record in records:
                    filtered_record = {}
                    for field in selected_fields:
                        if field in record:
                            filtered_record[field] = record[field]
                    filtered_records.append(filtered_record)
                records = filtered_records
            
            # Write based on format
            if file_format.lower() == 'csv':
                return self._write_csv(
                    records, 
                    file_path, 
                    include_headers, 
                    header_fields,
                    params
                )
            elif file_format.lower() in ['json', 'jsonl']:
                return self._write_json(
                    records, 
                    file_path, 
                    file_format.lower() == 'jsonl',
                    params
                )
            elif file_format.lower() == 'excel':
                return self._write_excel(
                    records, 
                    file_path, 
                    include_headers, 
                    header_fields,
                    params
                )
            elif file_format.lower() == 'txt':
                return self._write_text(
                    records, 
                    file_path, 
                    params
                )
            else:
                return False, f"Unsupported file format: {file_format}"
                
        except Exception as e:
            error_message = f"Error writing file: {str(e)}"
            logger.error(error_message)
            return False, error_message
    
    def _standardize_data(self, data: Any) -> List[Dict[str, Any]]:
        """
        Standardize data into a list of records.
        
        Args:
            data: Data in various formats
            
        Returns:
            List of dictionaries representing records
        """
        if data is None:
            return []
            
        if isinstance(data, list):
            # If it's already a list, check if items are dictionaries
            if data and isinstance(data[0], dict):
                return data
            else:
                # Convert simple list to list of dictionaries
                return [{'value': item} for item in data]
        elif isinstance(data, dict):
            # If it's a single dictionary, wrap it in a list
            return [data]
        else:
            # For other types, create a single-item list with a dictionary
            return [{'value': data}]
    
    def _write_csv(
        self,
        records: List[Dict[str, Any]],
        file_path: str,
        include_headers: bool,
        header_fields: List[str],
        params: Dict[str, Any]
    ) -> Tuple[bool, str]:
        """
        Write data to a CSV file.
        
        Args:
            records: List of record dictionaries
            file_path: Path to the output file
            include_headers: Whether to include headers
            header_fields: Custom header field names
            params: Additional parameters
            
        Returns:
            Tuple of (success, error_message)
        """
        try:
            # Get CSV options
            delimiter = params.get('csv_delimiter', ',')
            quotechar = params.get('csv_quotechar', '"')
            
            # Determine fields to include and their order
            if not records:
                return False, "No records to write"
                
            # Get all fields from the first record if none specified
            if not header_fields:
                header_fields = list(records[0].keys())
            
            # Create the CSV file
            with open(file_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.writer(csvfile, delimiter=delimiter, quotechar=quotechar)
                
                # Write header row if requested
                if include_headers:
                    writer.writerow(header_fields)
                
                # Write data rows
                for record in records:
                    row = [record.get(field, '') for field in header_fields]
                    writer.writerow(row)
            
            return True, ""
            
        except Exception as e:
            error_message = f"Error writing CSV file: {str(e)}"
            logger.error(error_message)
            return False, error_message
    
    def _write_json(
        self,
        records: List[Dict[str, Any]],
        file_path: str,
        as_jsonl: bool,
        params: Dict[str, Any]
    ) -> Tuple[bool, str]:
        """
        Write data to a JSON or JSONL file.
        
        Args:
            records: List of record dictionaries
            file_path: Path to the output file
            as_jsonl: Whether to write as JSONL (one JSON object per line)
            params: Additional parameters
            
        Returns:
            Tuple of (success, error_message)
        """
        try:
            # Get JSON options
            indent = params.get('json_indent', 2) if not as_jsonl else None
            ensure_ascii = params.get('json_ensure_ascii', False)
            
            if as_jsonl:
                # Write JSON Lines format (one object per line)
                with open(file_path, 'w', encoding='utf-8') as jsonfile:
                    for record in records:
                        json_string = json.dumps(record, ensure_ascii=ensure_ascii)
                        jsonfile.write(json_string + '\n')
            else:
                # Write standard JSON (entire array in one file)
                with open(file_path, 'w', encoding='utf-8') as jsonfile:
                    json.dump(records, jsonfile, indent=indent, ensure_ascii=ensure_ascii)
            
            return True, ""
            
        except Exception as e:
            error_message = f"Error writing JSON file: {str(e)}"
            logger.error(error_message)
            return False, error_message
    
    def _write_excel(
        self,
        records: List[Dict[str, Any]],
        file_path: str,
        include_headers: bool,
        header_fields: List[str],
        params: Dict[str, Any]
    ) -> Tuple[bool, str]:
        """
        Write data to an Excel file.
        
        Args:
            records: List of record dictionaries
            file_path: Path to the output file
            include_headers: Whether to include headers
            header_fields: Custom header field names
            params: Additional parameters
            
        Returns:
            Tuple of (success, error_message)
        """
        try:
            # Try to import openpyxl
            try:
                import openpyxl
                from openpyxl.utils import get_column_letter
            except ImportError:
                return False, "openpyxl module not found. Please install it to use Excel output."
            
            # Get Excel options
            sheet_name = params.get('excel_sheet_name', 'Data')
            
            # Determine fields to include and their order
            if not records:
                return False, "No records to write"
                
            # Get all fields from the first record if none specified
            if not header_fields:
                header_fields = list(records[0].keys())
            
            # Create a new workbook and sheet
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = sheet_name
            
            # Write header row if requested
            if include_headers:
                for col_idx, field in enumerate(header_fields, 1):
                    ws.cell(row=1, column=col_idx, value=field)
            
            # Write data rows
            start_row = 2 if include_headers else 1
            for row_idx, record in enumerate(records, start_row):
                for col_idx, field in enumerate(header_fields, 1):
                    ws.cell(row=row_idx, column=col_idx, value=record.get(field, ''))
            
            # Auto-size columns
            for col_idx, _ in enumerate(header_fields, 1):
                col_letter = get_column_letter(col_idx)
                max_length = 0
                for cell in ws[col_letter]:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(str(cell.value))
                    except:
                        pass
                adjusted_width = (max_length + 2)
                ws.column_dimensions[col_letter].width = min(adjusted_width, 50)  # Cap width at 50
            
            # Save the workbook
            wb.save(file_path)
            
            return True, ""
            
        except Exception as e:
            error_message = f"Error writing Excel file: {str(e)}"
            logger.error(error_message)
            return False, error_message
    
    def _write_text(
        self,
        records: List[Dict[str, Any]],
        file_path: str,
        params: Dict[str, Any]
    ) -> Tuple[bool, str]:
        """
        Write data to a plain text file.
        
        Args:
            records: List of record dictionaries
            file_path: Path to the output file
            params: Additional parameters
            
        Returns:
            Tuple of (success, error_message)
        """
        try:
            # Get text options
            format_template = params.get('text_format', '{record}')
            record_separator = params.get('text_record_separator', '\n')
            
            with open(file_path, 'w', encoding='utf-8') as txtfile:
                for i, record in enumerate(records):
                    # Format the record according to the template
                    try:
                        record_str = format_template.format(record=record, **record)
                    except KeyError:
                        # If formatting fails, fall back to simple string representation
                        record_str = str(record)
                    
                    # Write the record
                    txtfile.write(record_str)
                    
                    # Add separator if not the last record
                    if i < len(records) - 1:
                        txtfile.write(record_separator)
            
            return True, ""
            
        except Exception as e:
            error_message = f"Error writing text file: {str(e)}"
            logger.error(error_message)
            return False, error_message